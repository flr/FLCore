% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genericMethods.R, R/FLS.R
\name{accessors}
\alias{accessors}
\alias{name}
\alias{name,}
\alias{name<-}
\alias{name<-<-}
\alias{desc}
\alias{desc<-}
\alias{range<-}
\alias{catch}
\alias{catch<-}
\alias{catch.n<-}
\alias{catch.wt}
\alias{catch.wt<-}
\alias{discards}
\alias{discards<-}
\alias{discards.n}
\alias{discards.n<-}
\alias{discards.wt}
\alias{discards.wt<-}
\alias{landings}
\alias{landings<-}
\alias{landings.n}
\alias{landings.n<-}
\alias{landings.wt}
\alias{landings.wt<-}
\alias{m}
\alias{m<-}
\alias{stock}
\alias{stock<-}
\alias{stock.n}
\alias{stock.n<-}
\alias{stock.wt}
\alias{stock.wt<-}
\alias{m.spwn}
\alias{m.spwn<-}
\alias{harvest}
\alias{harvest<-}
\alias{harvest.spwn}
\alias{harvest.spwn<-}
\alias{mat}
\alias{mat<-}
\alias{n}
\alias{n<-}
\alias{wt}
\alias{wt<-}
\alias{fec}
\alias{fec<-}
\alias{spwn}
\alias{spwn<-}
\alias{effort}
\alias{effort<-}
\alias{type}
\alias{type<-}
\alias{distr}
\alias{distr<-}
\alias{distribution}
\alias{distribution<-}
\alias{index}
\alias{index<-}
\alias{index.var}
\alias{index.var<-}
\alias{catch.n}
\alias{sel.pattern}
\alias{sel.pattern<-}
\alias{index.q}
\alias{index.q<-}
\alias{model}
\alias{model<-}
\alias{logl}
\alias{logl<-}
\alias{gr}
\alias{gr<-}
\alias{initial}
\alias{initial<-}
\alias{logLik}
\alias{logLik<-}
\alias{vcov<-}
\alias{vcov}
\alias{hessian}
\alias{hessian<-}
\alias{logerror}
\alias{logerror<-}
\alias{details}
\alias{details<-}
\alias{residuals<-}
\alias{fitted}
\alias{fitted<-}
\alias{rec}
\alias{rec<-}
\alias{rec.obs}
\alias{rec.obs<-}
\alias{catch.q}
\alias{catch.q<-}
\alias{discards.sel}
\alias{discards.sel<-}
\alias{landings.sel}
\alias{landings.sel<-}
\alias{params}
\alias{params,}
\alias{params<-}
\alias{params<-<-}
\alias{catch<-,FLS,FLQuants-method}
\title{accessor and replacement methods for FLCore classes}
\usage{
name(object, ...)

desc(object, ...)

range(x, i) <- value

catch(object, ...)

catch.n(object, ...) <- value

catch.wt(object, ...)

discards(object, ...)

discards.n(object, ...)

discards.wt(object, ...)

landings(object, ...)

landings.n(object, ...)

landings.wt(object, ...)

m(object, ...)

stock(object, ...)

stock.n(object, ...)

stock.wt(object, ...)

m.spwn(object, ...)

harvest(object, catch, ...)

harvest.spwn(object, ...)

mat(object, ...)

n(object, ...)

m(object, ...)

wt(object, ...)

fec(object, ...)

spwn(object, ...)

effort(object, metier, ...)

type(object, ...)

distr(object, ...)

distribution(object, ...)

index(object, ...)

index.var(object, ...)

catch.n(object, ...)

catch.wt(object, ...)

sel.pattern(object, ...)

index.q(object, ...)

model(object, ...)

logl(object, ...)

gr(object, ...)

initial(object, ...)

logLik(object, ...)

vcov(object, ...) <- value

hessian(object, ...)

logerror(object, ...)

details(object, ...)

residuals(object, ...) <- value

fitted(object, ...)

rec(object, ...)

rec.obs(object, ...)

catch.q(object, ...)

discards.sel(object, ...)

landings.sel(object, ...)

params(object, ...)

\S4method{catch}{FLS,FLQuants}(object) <- value
}
\arguments{
\item{object}{The object from which a slot is to be extracted or replaced}

\item{value}{Object to be inserted into the relevant slot}
}
\value{
The required slot, for an accessor method, or invisible modifies the
object, for the replacement one.
}
\description{
All S4 classes defined in FLCore have methods for accessing and replacing any
of their slots. These methods are named as the slot, and will return the
content of the slot, for the accessor method, or modify it with the provided
value.
}
\details{
Accessors and replacement methods, with some exception, are created at build
time by calls to the \code{createFLAccessors} function. An accessor method is
created for each slot, with simply calls \code{slot()} on the relevant slot
name. For slots of class \code{\link{FLQuant}}, or \code{FLArray}-based, two
methods are created: one if \code{value} is of class \code{FLQuant}, and
another for \code{value} being a numeric vector. The later would insert the
vector into the slot structure, using R's recycling rules.

Users are encouraged to use the accessor methods, rather than the '@' operator
or the \code{slot()} method, to isolate code from the internal structure of
the class. If a slot was to be altered or deleted in the future, a method
would be provided to return the same value, computed from other slots.

Some of these methods might already not access directly an slot, and instead
carry out a calculation to return the requested value, depending on the class
being called with. Please refer to the particular method implementation to
see if this is the case.

Accessor methods for slots of class \code{\link{predictModel}} behave
differently depending on the \code{compute} argument. Please refer to the
relevant help page for further clarification.

An object of class FLQuants, containing three elements named
\emph{catch}, \emph{catch.n} and \emph{catch.wt}, as returned by \code{\link{computeCatch}}, can be
assigned directly to an object using \emph{catch<-}.
}
\examples{

data(ple4)

# To access the catch slot in an FLStock, use
catch(ple4)

# while to modify it, do
catch(ple4) <- catch(ple4) * 2

# A number can be used as input, to be recycled
m(ple4) <- 0.3
# same as a longer vector, by age
m(ple4) <- 0.4^(seq(1, 2, length=10))

# To see the methods defined by createFLAccessors, run, for example
getMethod('catch', 'FLS')

# Assign the 3 catch slots
catch(ple4) <- computeCatch(ple4, slot="all")
}
\seealso{
\code{\link{FLQuant}}, \code{\link{FLStock}}, \code{\link{FLIndex}},
\code{\link{FLBiol}}, \code{\link{predictModel}}
}
\author{
The FLR Team
}
\keyword{methods}
