% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genericMethods.R, R/operators.R
\docType{methods}
\name{\%+\%}
\alias{\%+\%}
\alias{\%}
\alias{\%+\%-methods}
\alias{\%-\%}
\alias{\%-\%-methods}
\alias{\%^\%}
\alias{\%^\%-methods}
\alias{operators}
\alias{\%*\%,FLQuant,FLQuant-method}
\alias{\%/\%,FLQuant,FLQuant-method}
\alias{\%+\%,FLQuant,FLQuant-method}
\alias{\%-\%,FLQuant,FLQuant-method}
\alias{\%^\%,FLQuant,FLQuant-method}
\alias{\%*\%,FLPar,FLQuant-method}
\alias{\%/\%,FLPar,FLQuant-method}
\alias{\%+\%,FLPar,FLQuant-method}
\alias{\%-\%,FLPar,FLQuant-method}
\alias{\%^\%,FLPar,FLQuant-method}
\alias{\%*\%,FLQuant,FLPar-method}
\alias{\%/\%,FLQuant,FLPar-method}
\alias{\%+\%,FLQuant,FLPar-method}
\alias{\%-\%,FLQuant,FLPar-method}
\alias{\%^\%,FLQuant,FLPar-method}
\alias{\%*\%,FLPar,FLPar-method}
\alias{\%+\%,FLPar,FLPar-method}
\alias{\%-\%,FLPar,FLPar-method}
\alias{\%/\%,FLPar,FLPar-method}
\alias{\%^\%,FLPar,FLPar-method}
\alias{/,FLQuants,FLPar-method}
\alias{*,FLQuants,FLPar-method}
\alias{/,FLQuants,FLPars-method}
\alias{*,FLQuants,FLPars-method}
\alias{/,FLQuants,FLQuants-method}
\alias{*,FLQuants,FLQuants-method}
\alias{+,FLQuants,FLQuants-method}
\alias{-,FLQuants,FLQuants-method}
\title{FLQuant arithmetic operators that extend objects}
\usage{
e1 \%+\% e2

x \%-\% y

x \%^\% y

\S4method{\%*\%}{FLQuant,FLQuant}(x, y)

\S4method{\%/\%}{FLQuant,FLQuant}(e1, e2)

\S4method{\%+\%}{FLQuant,FLQuant}(e1, e2)

\S4method{\%-\%}{FLQuant,FLQuant}(x, y)

\S4method{\%^\%}{FLQuant,FLQuant}(x, y)

\S4method{\%*\%}{FLPar,FLQuant}(x, y)

\S4method{\%/\%}{FLPar,FLQuant}(e1, e2)

\S4method{\%+\%}{FLPar,FLQuant}(e1, e2)

\S4method{\%-\%}{FLPar,FLQuant}(x, y)

\S4method{\%^\%}{FLPar,FLQuant}(x, y)

\S4method{\%*\%}{FLQuant,FLPar}(x, y)

\S4method{\%/\%}{FLQuant,FLPar}(e1, e2)

\S4method{\%+\%}{FLQuant,FLPar}(e1, e2)

\S4method{\%-\%}{FLQuant,FLPar}(x, y)

\S4method{\%^\%}{FLQuant,FLPar}(x, y)

\S4method{\%*\%}{FLPar,FLPar}(x, y)

\S4method{\%+\%}{FLPar,FLPar}(e1, e2)

\S4method{\%-\%}{FLPar,FLPar}(x, y)

\S4method{\%/\%}{FLPar,FLPar}(e1, e2)

\S4method{\%^\%}{FLPar,FLPar}(x, y)

\S4method{/}{FLQuants,FLPar}(e1, e2)

\S4method{*}{FLQuants,FLPar}(e1, e2)

\S4method{/}{FLQuants,FLPars}(e1, e2)

\S4method{*}{FLQuants,FLPars}(e1, e2)

\S4method{/}{FLQuants,FLQuants}(e1, e2)

\S4method{*}{FLQuants,FLQuants}(e1, e2)

\S4method{+}{FLQuants,FLQuants}(e1, e2)

\S4method{-}{FLQuants,FLQuants}(e1, e2)
}
\description{
Arithmetic operations between two \linkS4class{FLQuant} objects using the
standars operators (\code{+}, \code{-}, \code{*}, \code{/}, \code{^}, see \link{Arith}) need all
dimensions in both objects to match. This requirement is relaxed by using
the percent version of those five operators: \verb{\%+\%}, \verb{\%-\%}, \code{\%*\%}, \code{\%/\%} and
\verb{\%^\%}.
}
\details{
If any of the objects is of length one in a dimensions where the other is
longer, the dimensions will be extended and the element-by-element operation
then conducted. Dimensions and dimnames of the output will be those of the
larger object. See the examples to observe their behaviour.

Please note that this behaviour is already present on the \link{Arith}
methods for \linkS4class{FLArray}-derived classes but only on the 6th,
\code{iter}, dimension.

The original use of the \code{\%*\%} operator, as vector product, is not available
for \linkS4class{FLQuant} objects, but can be applied to the \link{array}
inside them, as in the example below.

Methods for operations between an \linkS4class{FLQuant} and an
\linkS4class{FLPar} object will match dimensions by names of dimnames,
regardless of position.
}
\section{Generic function}{
 x \%+\% y, x \%-\% y, x \%*\% y, e1 \%/\% e2, x \%^\% y
}

\examples{

a <- FLQuant(2, dim=c(3,3,2))
b <- FLQuant(3, dim=c(3,3,1))

# This should fail
\dontrun{ a * b }

a \%*\% b
a \%+\% b
# To use base's \%*\% vector product, apply it to a matrix from @.Data
b@.Data[,,,,,] \%*\% 1:3
# or
b[,,drop=TRUE] \%*\% 1:3

# FLPar vs. FLQuant works by dimnames' names
flp <- FLPar(2, dimnames=list(params='a', year=2000:2005, iter=1))
flq <- FLQuant(3, dimnames=list(year=2000:2005))
flp \%*\% flq

# Divide each FLQuants element by a 'param' in FLPar, e.g. time series
# divide by reference points
FLQuants(SSB=FLQuant(2303), F=FLQuant(0.8)) / FLPar(SSB=1560, F=0.4)

# Product of each FLQuants element by a 'param' in FLPar
FLQuants(SSB=FLQuant(2303), F=FLQuant(0.8)) * FLPar(SSB=1560, F=0.4)
# Divide each FLQuants element by each in FLPars
FLQuants(A=FLQuant(2303), B=FLQuant(1287)) /
  FLPars(A=FLPar(SBMSY=1560), B=FLPar(SBMSY=1000))
# Divide each FLQuants element by each in FLPars
FLQuants(A=FLQuant(2303), B=FLQuant(1287)) *
  FLPars(A=FLPar(SBMSY=1560), B=FLPar(SBMSY=1000))
# Divide each FLQuants element by each in FLPars
FLQuants(A=FLQuant(300), B=FLQuant(200)) /
  FLQuants(A=FLQuant(3), B=FLQuant(2))
# Divide each FLQuants element by each in FLPars
FLQuants(A=FLQuant(100), B=FLQuant(200)) *
  FLQuants(A=FLQuant(3), B=FLQuant(2))
# Divide each FLQuants element by each in FLPars
FLQuants(A=FLQuant(100), B=FLQuant(200)) *
  FLQuants(A=FLQuant(3), B=FLQuant(2))
# Divide each FLQuants element by each in FLPars
FLQuants(A=FLQuant(100), B=FLQuant(200)) *
  FLQuants(A=FLQuant(3), B=FLQuant(2))
}
\seealso{
\code{\linkS4class{FLQuant}}, \code{\link[base]{matmult}}
}
\author{
The FLR Team
}
\keyword{methods}
